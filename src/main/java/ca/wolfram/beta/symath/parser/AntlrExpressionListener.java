package ca.wolfram.beta.symath.parser;

import java.util.ArrayList;
import java.util.Stack;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.TerminalNode;

import ca.wolfram.beta.symath.MathNode;
import ca.wolfram.beta.symath.MathUtils;
import ca.wolfram.beta.symath.base.BaseNode;
import ca.wolfram.beta.symath.operations.AddNode;
import ca.wolfram.beta.symath.operations.DivideNode;
import ca.wolfram.beta.symath.operations.MultiplyNode;
import ca.wolfram.beta.symath.operations.NegateNode;
import ca.wolfram.beta.symath.operations.PowerNode;
import ca.wolfram.beta.symath.operations.SubtractNode;
import ca.wolfram.beta.symath.parser.ExpressionParser.AtomContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.DecimalContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.DigitsContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.EquationContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.ExpressionContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.FactorContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.ProgContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.RelopContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.ScientificContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.TermContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.VariableContext;
import ca.wolfram.beta.symath.parser.ExpressionParser.WholenumberContext;

public class AntlrExpressionListener implements ExpressionListener{

    private Stack<ArrayList<MathNode>> nodesStack = new Stack<ArrayList<MathNode>>();
    private MathNode rootNode;

    public MathNode getExpression() {
        return rootNode;
    }

    // Auto generated by the parser

    @Override
    public void enterEveryRule(ParserRuleContext arg0) {
        // TODO Auto-generated method stub
    }

    @Override
    public void exitEveryRule(ParserRuleContext arg0) {
        // TODO Auto-generated method stub
    }

    @Override
    public void visitErrorNode(ErrorNode arg0) {
        // TODO Auto-generated method stub
    }

    @Override
    public void visitTerminal(TerminalNode arg0) {
        // TODO Auto-generated method stub
    }

    @Override
    public void enterProg(ProgContext ctx) {
        //System.out.println("Enter Prog: " + ctx.getText());
        nodesStack.push(new ArrayList<MathNode>());
    }

    @Override
    public void exitProg(ProgContext ctx) {
        rootNode = nodesStack.pop().get(0);
    }

    // Unused

    @Override
    public void enterEquation(EquationContext ctx) {
        // TODO Auto-generated method stub
    }

    @Override
    public void exitEquation(EquationContext ctx) {
        // TODO Auto-generated method stub
    }

    // for an expression in the format "a+b+c-d-e...". Created in the format SubtractNode(AddNode(a, b, c), d, e)

    @Override
    public void enterExpression(ExpressionContext ctx) {
        nodesStack.push(new ArrayList<MathNode>());
        //System.out.println("Entered Expression " + ctx.getText() + ", current stack size: " + nodesStack.size());
    }

    @Override
    public void exitExpression(ExpressionContext ctx) {
        ArrayList<MathNode> children = nodesStack.pop();

        ArrayList<MathNode> add = new ArrayList<MathNode>();
        ArrayList<MathNode> subtract = new ArrayList<MathNode>();
        add.add(children.get(0));
        for (int i = 1; i < children.size(); i++) {
            if( ctx.getChild(i*2-1).getText().equals("+")) {
                add.add(children.get(i));
            } else {
                subtract.add(children.get(i));
            }
        }

        MathNode expression;
        if (add.size() == 1) expression = add.get(0);
        else expression = AddNode.create(add);
        if (!subtract.isEmpty()) {
            subtract.add(0, expression);
            expression = SubtractNode.create(subtract);
        }

        nodesStack.peek().add(expression);
        //System.out.println("Exit Expression, current stack size: " + nodesStack.size());
    }

    // for a term in the format "a*b*c/d/e..." Created in the format DivideNode(MultiplyNode(a, b, c), d, e))

    @Override
    public void enterTerm(TermContext ctx) {
        nodesStack.push(new ArrayList<MathNode>());
        //System.out.println("Entered Term " + ctx.getText() + " , current stack size: " + nodesStack.size());
    }

    @Override
    public void exitTerm(TermContext ctx) {
        ArrayList<MathNode> children = nodesStack.pop();

        ArrayList<MathNode> multiply = new ArrayList<MathNode>();
        ArrayList<MathNode> divide = new ArrayList<MathNode>();
        multiply.add(children.get(0));
        for (int i = 1; i < children.size(); i++) {
            if( ctx.getChild(i*2-1).getText().equals("*")) {
                multiply.add(children.get(i));
            } else {
                divide.add(children.get(i));
            }
        }

        MathNode term;
        if (multiply.size() == 1) term = multiply.get(0);
        else term = MultiplyNode.create(multiply);
        if (!divide.isEmpty()) {
            divide.add(0, term);
            term = DivideNode.create(divide);
        }

        nodesStack.peek().add(term);
        //System.out.println("Exit Term, current stack size: " + nodesStack.size());
    }

    // For a factors in the format "a^b". Created in the format PowerNode(a, b)

    @Override
    public void enterFactor(FactorContext ctx) {
        nodesStack.push(new ArrayList<MathNode>());
        //System.out.println("Entered Factor " + ctx.getText() + " , current stack size: " + nodesStack.size());
    }

    @Override
    public void exitFactor(FactorContext ctx) {
        ArrayList<MathNode> children = nodesStack.pop();
        MathNode factor = BaseNode.ZERO;
        if (children.size() == 2) factor = PowerNode.create(children.get(0), children.get(1));
        else if (children.size() == 1) factor = children.get(0);
        else System.out.println("FACTOR HAS AN INCORRECT NUMBER OF CHILDREN" + children.size());
        nodesStack.peek().add(factor);
        //System.out.println("Exit Factor, current stack size: " + nodesStack.size());
    }

    // This is just a parser remnant.

    @Override
    public void enterAtom(AtomContext ctx) {
        // TODO Auto-generated method stub

    }

    @Override
    public void exitAtom(AtomContext ctx) {
        // TODO Auto-generated method stub
    }

    // for scientific notations in the format "aEb". Created in the format MultiplyNode(a PowerNode(10, b))

    @Override
    public void enterScientific(ScientificContext ctx) {
        nodesStack.push(new ArrayList<MathNode>());
        //System.out.println("Entered Scientific " + ctx.getText() + " , current stack size: " + nodesStack.size());
    }

    @Override
    public void exitScientific(ScientificContext ctx) {
        ArrayList<MathNode> children = nodesStack.pop();
        MathNode scientific = BaseNode.ZERO;
        if (children.size() == 2) scientific = MultiplyNode.create(children.get(0), PowerNode.create(BaseNode.create(10l), children.get(1)));
        else if (children.size() == 1) scientific = children.get(0);
        else System.out.println("SCIENTIFIC HAS AN INCORRECT NUMBER OF CHILDREN: " + children.size());
        nodesStack.peek().add(scientific);
        //System.out.println("Exit Scientific, current stack size: " + nodesStack.size());
    }

    // for numbers in the format "a.b". Created in the format AddNode(a DivideNode(b, b.length))

    @Override
    public void enterDecimal(DecimalContext ctx) {
        nodesStack.push(new ArrayList<MathNode>());
        //System.out.println("Entered Number " + ctx.getText() + " , current stack size: " + nodesStack.size());
    }

    @Override
    public void exitDecimal(DecimalContext ctx) {
        ArrayList<MathNode> children = nodesStack.pop();
        if (ctx.getChild(0).getText() == "-") children.set(0, NegateNode.create(children.get(0)));
        MathNode num = BaseNode.ONE;
        switch (children.size()) {
        case 2:
            MathNode unit = children.get(0);
            MathNode decimal = children.get(1);
            decimal = DivideNode.create(decimal, BaseNode.create((long) Math.pow(10, decimal.toString().length())));
            if (MathUtils.isNegativeConstant(unit)) decimal = NegateNode.create(decimal);
            num = AddNode.create(unit, decimal);
            break;
        case 1:
            num = children.get(0);
            break;
        default:
            System.out.println("NUMBER HAS AN INCORRECT NUMBER OF CHILDREN: " + children.size());
            break;
        }
        nodesStack.peek().add(num);
        //System.out.println("Exit Number, current stack size: " + nodesStack.size());
    }

    // for numbers in the format "-a" Created in the format NegateNode(a)

    @Override
    public void enterWholenumber(WholenumberContext ctx) {
        nodesStack.push(new ArrayList<MathNode>());
        //System.out.println("Entered WholeNumber " + ctx.getText() + " , current stack size: " + nodesStack.size());
    }

    @Override
    public void exitWholenumber(WholenumberContext ctx) {
        MathNode wholeNumber = nodesStack.pop().get(0);
        if (ctx.getChild(0).getText().equals("-")) wholeNumber = NegateNode.create(wholeNumber);
        nodesStack.peek().add(wholeNumber);
        //System.out.println("Exit WholeNumber, current stack size: " + nodesStack.size());
    }

    // Below functions do not add a new layer on the stack.

    @Override
    public void enterVariable(VariableContext ctx) {
        //System.out.println("\tVariable: " + ctx.getText());
        String string = ctx.getText();
        MathNode var = BaseNode.ZERO;
        boolean negative = false;
        if (string.startsWith("-")) {
            negative = true;
            string = string.substring(1);
        }
        switch (string) {
        case "pi":
            var = BaseNode.create("pi", Math.PI);
            break;
        case "e":
            var = BaseNode.create("e", Math.E);
            break;
        default :
            var = BaseNode.create(string, false);
            break;
        }
        if (negative) var = NegateNode.create(var);
        nodesStack.peek().add(var);
    }

    @Override
    public void exitVariable(VariableContext ctx) {
    }

    @Override
    public void enterDigits(DigitsContext ctx) {
        //System.out.println("\tDigits: " + ctx.getText());
        nodesStack.peek().add(BaseNode.create(Long.parseLong(ctx.getText())));
    }

    @Override
    public void exitDigits(DigitsContext ctx) {
    }

    // Currently Unused

    @Override
    public void enterRelop(RelopContext ctx) {
        // TODO Auto-generated method stub

    }

    @Override
    public void exitRelop(RelopContext ctx) {
        // TODO Auto-generated method stub

    }







}
